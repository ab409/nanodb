CS122 Assignment 2 - SQL Planning and Joins - Design Document
=============================================================

A:  Logistics
-------------

A1.  List your team name and the people who worked on this assignment.

     <team name>

     <name>
     <name>
     ...

A2.  Specify the tag name and commit-hash of the Git version you are
     submitting for your assignment.  (You can list the commit hashes
     of your repository tags with this command:  git show-ref --tags)

     Tag name:     <tag>
     Commit hash:  <hash>

A3.  Specify any late tokens you are applying to this assignment, or
     "none" if no late tokens.

A4.  Briefly describe what parts of the assignment each teammate focused on.

B:  Simple Planner
------------------

B1.  Without going into the details of how you handle grouping and
     aggregation or joins, list the general sequence of steps that your
     planner's makePlan() method follows to translate a SQL query into
     an execution plan.

B2.  Describe how you generate the execution-plan fragment for the query's
     FromClause.  Make sure to touch on what you do in the three cases your
     planner is expected to handle - tables, subqueries in the FROM clause,
     and joins.

B3.  Describe how you implemented support for grouping and aggregation.
     Be sure to note any variations from the approach outlined in class,
     if there are any.

B4.  Does your planner try to implement any simplifications in specific
     circumstances, e.g. when a "trivial project" is used (i.e. "SELECT *
     FROM ...") in your planner?  Briefly enumerate simplifications and
     optimizations here.

C:  Nested-Loop Join
--------------------

C1.  The join algorithm stated in class is really only suitable for
     materialized evaluation, where the entire result is generated by the
     algorithm.  It is completely unsuitable for pipelined evaluation,
     where results are generated row by row.

     Summarize how your implementation works for inner joins, using
     pseudocode to show how rows are considered and returned as the
     algorithm executes, and what state must be saved so that the
     operation can resume at the appropriate place when the next row
     must be returned.

C2.  What tweaks did you need to introduce into the implementation for
     left outer joins?  Keep your answer brief, but please also be specific.

C3.  Same question as for C2, but for semijoins.

C4.  Same question as for C2, but for antijoins.

C5.  Enumerate your nested-loop join test cases, following this form:

     * <test-case class name>.<test function>
       <brief one-sentence description of what the test exercises>

D:  Extra Credit [OPTIONAL]
---------------------------

If you implemented any extra-credit tasks for this assignment, describe
them here.  The description should be like this, with stuff in "<>" replaced.
(The value i starts at 1 and increments...)

D<i>:  <one-line description>

     <brief summary of what you did, including the specific classes that
     we should look at for your implementation>

     <brief summary of test-cases that demonstrate/exercise your extra work>

E:  Feedback [OPTIONAL]
-----------------------

These questions are optional, and they obviously won't affect your grade
in any way (including if you hate everything about the assignment and
databases in general, or Donnie and the TAs in particular).

NOTE:  If you wish to give anonymous feedback, a similar survey will be
       made available on the Moodle.  

E1.  How many hours total did your team spend on this assignment?
     (That is, the sum of each teammate's time spent on the assignment.)

E2.  What parts of the assignment were most time-consuming?

E3.  Which parts of the assignment did you particularly enjoy?

E4.  Which parts did you particularly dislike?

E5.  Do you have any suggestions for how future versions of the
     assignment can be improved?


