CS122 Assignment 2 - SQL Planning and Joins - Design Document
=============================================================

A:  Logistics
-------------

A1.  List your team name and the people who worked on this assignment.

     BBB

     Ryan Batterman
     Alex Bello
     Ronnel Boettcher

A2.  Specify the tag name and commit-hash of the Git version you are
     submitting for your assignment.  (You can list the commit hashes
     of your repository tags with this command:  git show-ref --tags)

     Tag name:     hw2
     Commit hash:  0444bbc3bf350aa

A3.  Specify any late tokens you are applying to this assignment, or
     "none" if no late tokens.

     None

A4.  Briefly describe what parts of the assignment each teammate focused on.

     Ryan focused on grouping/aggregation and architecting the simple query planner.
     Ronnel focused on integrating joins with the simple query planner and testing.
     Bello focused on joins and testing.

B:  Simple Planner
------------------

B1.  Without going into the details of how you handle grouping and
     aggregation or joins, list the general sequence of steps that your
     planner's makePlan() method follows to translate a SQL query into
     an execution plan.

     makePlan calls makeGeneralSelect, which in turn:
     1) Constructs base plan tree from the FROM clause part of the select statement.
     2) Wraps a plan node for the WHERE clause around this
     3) Wraps a plan node for grouping/aggregation around that
     4) Wraps a plan node for the having clause around this result
     5) Wraps a plan node to project the result around (4)'s result
     6) Appends on a node for an order-by clause.

     Some queries will not have to perform some of the above steps (e.g. there
     may be no order-by clause) -- in these cases, no node is added to the
     list.

     (1) may need to call auxiliary functions to construct plan nodes for the join
     expressions in the select statement.

B2.  Describe how you generate the execution-plan fragment for the query's
     FromClause.  Make sure to touch on what you do in the three cases your
     planner is expected to handle - tables, subqueries in the FROM clause,
     and joins.

     * If there is no fromClause, then we do nothing
     * If the from clause refers to a base table, we open a FileScan node for that
       and return it.
     * If there is a join expression, we first create plan nodes for the left 
       and right from clauses. We rename the nodes by their alias (if 
       applicable), and then wrap them in a NestedLoopsJoinNode. The 
       arguments passed to the NestedLoopsJoinNode are dependent on the type
       of join. In a JOIN_ON_EXPR, we pass the ON expression in the select
       clause. In a JOIN_USING, we construct an equality expression for the
       USING columns specified in the select clause. And for a natural join,
       we create an equality expression for the columns in common with both
       tables. Also since we have only a LEFT OUTER JOIN implementation, to
       handle RIGHT OUTER JOIN, we call swap() on the join node after 
       constuction. Lastly, we project the resulting join node to the schema
       prepared by the initial from clause (getPreparedSelectValues()).
     * Otherwise, we have a nested subquery; we construct plan nodes for the 
       subquery by recursively calling the planner on the subquery.

B3.  Describe how you implemented support for grouping and aggregation.
     Be sure to note any variations from the approach outlined in class,
     if there are any.

     1) Replace any references to aggregate functions in the select 
      	clause and the HAVING clause with column references. If any doubly-nested
	aggregate functions are encountered, we raise an error.
     2) We check if there are any aggregate functions in the WHERE expression /
     	FROM clause; if so, we signal an error.
     3) If we encountered no aggregation functions and no group-by expressions,
     	we do nothing.
     4) Otherwise, we construct an aggregation node specifying the group-by
     	expressions and the new mapping between column names and aggregates.

     It's the same as what was suggested in class.

B4.  Does your planner try to implement any simplifications in specific
     circumstances, e.g. when a "trivial project" is used (i.e. "SELECT *
     FROM ...") in your planner?  Briefly enumerate simplifications and
     optimizations here.

     If there is a trivial project, we don't construct a project node.
     If there is no HAVING expression / order-by clause / FROM clause /
     grouping/aggregation / WHERE clause -- then we don't construct the
     associated node.

C:  Nested-Loop Join
--------------------

C1.  The join algorithm stated in class is really only suitable for
     materialized evaluation, where the entire result is generated by the
     algorithm.  It is completely unsuitable for pipelined evaluation,
     where results are generated row by row.

     Summarize how your implementation works for inner joins, using
     pseudocode to show how rows are considered and returned as the
     algorithm executes, and what state must be saved so that the
     operation can resume at the appropriate place when the next row
     must be returned.


     NOTE: There are probably ways to do this much cleaner! Some of what we 
     considered besides the current approach: 
        *   using exceptions to communicate events from getTuplesToJoin() to
            getNextTuple() (but that's probably even dirtier, as it serves as a cross-function goto)
        *   Writing different getTuplesToJoin() functions for different kinds of joins. This would
            certainly make each function cleaner, but a lot of code would be repeated, making
            refactoring and maintainability hard.

    The main idea is the following: The leftChild and rightChild iterators are used to emulate
    the nested for loop. In the simple inner join case, the rightChild iterator would be exhausted
    (until we got null), then the leftChild iterator would be called once, then the right one 
    initialized again and started over. This is done all the way until the leftChild iterator is exhausted,
    hence completing the n^2 iterations:

    Step 1: Initialize both right and left iterators
    Step 2: Advance right iterator, return true if we don't get null
    Step 3: If we get null, move the left iterator, re-initiate the rigth one
    Step 4: If the right iterator returned null, we're done. Otherwise return true

    For the simple inner joins no extra state must be stored (the state of the iterators is enough).
    For other kinds of joins, some extra pieces of information must be stored, so that getTuplesToJoin()
    and getNextTuple() can communicate together.





C2.  What tweaks did you need to introduce into the implementation for
     left outer joins?  Keep your answer brief, but please also be specific.
        
        Added the following flags to keep track of state:
            * matchedRow: a flag that is set to true iff the outer loop had a matching row (hence no null padding needed)
            * padnull: A flag set to true iff getNextTuple() needs to disregard one of the children. When seeing this set to
            true, getNextTuple() should pad null

C3.  Same question as for C2, but for semijoins.

        Added the following flags to keep track of state:
            * breakInner: a flag that is set to true iff getNextTuple() wants getTUplesToJoin() to re-initiate the
            right iterator and move the left one. Used for semijoins so that if a match is found, we can break the inner
            loop.

C4.  Same question as for C2, but for antijoins.

        Added the following flags to keep track of state:
            * breakInner: a flag that is set to true iff getNextTuple() wants getTUplesToJoin() to re-initiate the
            right iterator and move the left one. Used for antijoins so that if a match is found, we can break the inner
            loop.
            * unmatchedRow: a flag set to true iff we're done with the inner loop, and the outer row has NO matching
            rows. This is used so getTuplesToJoin() tells getNextTuple() that the iteration is done, and no matching 
            rows were found. Used in antijoin to tell whether the current row should be included or not

C5.  Enumerate your nested-loop join test cases, following this form:

     * <test-case class name>.<test function>
       <brief one-sentence description of what the test exercises>


       For inner joins:
       TestSimpleJoins.testInnerSimple: This test performs a simple inner join between two non-empty tables
       TestSimpleJoins.testInnerEmptyRight: This test performs an inner join between a empty table (left) and a non-empty table
       TestSimpleJoins.testInnerEmptyLeft: This test performs an inner join between a empty table (right) and a non-empty table
       TestSimpleJoins.testInnerEmptyBoth: This test performs an inner join between two empty tables
       TestSimpleJoins.testInnerDupRight: This tests performs an inner join between two nonempty tables where multiple rows of the right table would join
       TestSimpleJoins.testInnerDupLeft: TestSimpleJoins.testInnerDupRight: This tests performs an inner join between two nonempty tables where multiple rows of the left table would join

       For Left Outer Joins:
       TestSimpleJoins.testLOJSimple: Same as before, but for LOJ
       TestSimpleJoins.testLOJEmptyRight:Same as before, but for LOJ
       TestSimpleJoins.testLOJEmptyLeft: Same as before, but for LOJ
       TestSimpleJoins.testLOJEmptyBoth: Same as before, but for LOJ
       TestSimpleJoins.testLOJDupRight: Same as before, but for LOJ
       TestSimpleJoins.testLOJDupLeft: Same as before, but for LOJ

       For Right Outer Joins:
       TestSimpleJoins.testROJSimple: Same as before, but for ROJ
       TestSimpleJoins.testROJEmptyRight:Same as before, but for ROJ
       TestSimpleJoins.testROJEmptyLeft: Same as before, but for ROJ
       TestSimpleJoins.testROJEmptyBoth: Same as before, but for ROJ
       TestSimpleJoins.testROJDupRight: Same as before, but for ROJ
       TestSimpleJoins.testROJDupLeft: Same as before, but for ROJ

       NOTE: Very similar tests were also written for USING and NATURAL, as part of extra credit

D:  Extra Credit [OPTIONAL]
---------------------------

If you implemented any extra-credit tasks for this assignment, describe
them here.  The description should be like this, with stuff in "<>" replaced.
(The value i starts at 1 and increments...)

D<i>:  <one-line description>

     <brief summary of what you did, including the specific classes that
     we should look at for your implementation>

     <brief summary of test-cases that demonstrate/exercise your extra work>

     We implemented tests for USING and NATURAL JOIN clauses. These tests are
     in test/nanodb/sql/TestUsingJoins.java and 
     test/nanodb/sql/TestNaturalJoins.java, respectively. They both cover the 
     following tests -- a simple join with two non-empty tables. Then tests 
     where both left and right tables are empty. Then a test where both tables
     are empty. Then tests where the left and right tables both have multiple 
     rows that should join. 

E:  Feedback [OPTIONAL]
-----------------------

These questions are optional, and they obviously won't affect your grade
in any way (including if you hate everything about the assignment and
databases in general, or Donnie and the TAs in particular).

NOTE:  If you wish to give anonymous feedback, a similar survey will be
       made available on the Moodle.  

E1.  How many hours total did your team spend on this assignment?
     (That is, the sum of each teammate's time spent on the assignment.)

E2.  What parts of the assignment were most time-consuming?

E3.  Which parts of the assignment did you particularly enjoy?

E4.  Which parts did you particularly dislike?

E5.  Do you have any suggestions for how future versions of the
     assignment can be improved?


